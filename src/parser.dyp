%start main

%lexer

main lexer =
[' ' '\t' '\n'] ->
(['1'-'9']?['0'-'9']+) -> INT { int_of_string (Dyp.lexeme lexbuf) }
(['1'-'9']?['0'-'9']+['.']['0'-'9']+)|(['.']['0'-'9']+) -> FLOAT { float_of_string (Dyp.lexeme lexbuf) }
([^'"']|['\\']['"']) -> DBL_STRCH { Dyp.lexeme lexbuf }
([^''']|['\\'][''']) -> SGL_STRCH { Dyp.lexeme lexbuf } 
(['a'-'z']|['A'-'Z']|'_')(['0'-'9']|['a'-'z']|['A'-'Z']|'_')* -> IDENT_CHARS { Dyp.lexeme lexbuf }
"\"" -> DBL_QUOTE
"'" -> SGL_QUOTE

%parser

main
  : expr { $1 }

expr:
  | require_def { $1 }
  | let_def { $1 }
  | var_def { $1 }
  | int_def { $1 }
  | float_def { $1 }
  | string_def { $1 }
  | function_def { $1 }
  | return_def { $1 }
  | paren_def { $1 }

require_def:
  | "require" str { Ast.REQUIRE($2) }

let_def:
  | "let" let_assign_list { Ast.LET($2) }

var_def:
  | "var" var_assign_list { Ast.VAR($2) }

int_def:
  | INT { Ast.INT($1) }

float_def:
  | FLOAT { Ast.FLOAT($1) }

string_def:
  | str { Ast.STRING($1) }

function_def:
  | "def" ident "(" args ")" "{" expr_list "}" { Ast.FUNCTION($2, $4, $7) }

return_def:
  | "return" expr { Ast.RETURN($2) }

paren_def:
  | "(" expr_semicolon_list ")" { Ast.PAREN($2) }

expr_semicolon_list:
  | expr_semicolon_list ";" expr { List.append $1 [$3] }
  | expr { [$1] }

expr_list:
  | expr_list expr { List.append $1 [$2] }
  | expr { [$1] }

args:
  | args ident { List.append $1 [$2] }
  | ident { [$1] }


let_assign_list:
  |  let_assign ["," let_assign {$2}]* { $1::$2 }

var_assign_list:
  |  var_assign ["," var_assign {$2}]* { $1::$2 }

let_assign:
  | ident "=" expr { ($1,$3) }

var_assign:
  | ident "=" expr { ($1,$3) }

str:
  | DBL_QUOTE double_str_contents DBL_QUOTE { $2 }
  | SGL_QUOTE single_str_contents SGL_QUOTE { $2 }

ident:
  | IDENT_CHARS { $1 }

double_str_contents:
  | DBL_STRCH* { String.concat "" $1 }

single_str_contents:
  | SGL_STRCH* { String.concat "" $1 }